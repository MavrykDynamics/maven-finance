// ------------------------------------------------------------------------------
// Common Types
// ------------------------------------------------------------------------------

// General Contracts: generalContractsType, updateGeneralContractsParams
#include "../partials/generalContractsType.ligo"

// Whitelist Token Contracts: whitelistTokenContractsType, updateWhitelistTokenContractsParams 
#include "../partials/whitelistTokenContractsType.ligo"

// ------------------------------------------------------------------------------
// Contract Types
// ------------------------------------------------------------------------------

#include "../partials/vault/vaultType.ligo"

// ------------------------------------------------------------------------------

type vaultIdType                 is nat;
type usdmAmountType              is nat;
type tokenBalanceType            is nat;

type vaultOwnerType              is address;
type initiatorAddressType        is address;
type tokenContractAddressType    is address;

type collateralNameType          is string;

type mintOrBurnParamsType is [@layout:comb] record [
    quantity  : int;
    target    : address;
];

type vaultDepositStakedMvkType is [@layout:comb] record [
    depositAmount   : nat;
    vaultId         : nat; 
]

type vaultWithdrawStakedMvkType is [@layout:comb] record [
    withdrawAmount  : nat;
    vaultId         : nat; 
]

type vaultLiquidateStakedMvkType is [@layout:comb] record [
    liquidatedAmount  : nat; 
    vaultId           : nat;
    vaultOwner        : address; 
    liquidator        : address; 
]

// ------------------------------------------------------------------------------


// ----- storage types begin -----
type collateralTokenRecordType is [@layout:comb] record [
    tokenName               : string;
    tokenContractAddress    : address;
    tokenType               : tokenType; // from vaultType.ligo partial - Tez, FA12, FA2
    decimals                : nat; 
    oracleType              : string;    // "CFMM", "ORACLE" - use string instead of variant in case of future changes
    oracleAddress           : address;   // zeroAddress if no oracle
]
type collateralTokenLedgerType is map(string, collateralTokenRecordType) 

type collateralBalanceLedgerType  is map(collateralNameType, tokenBalanceType) // to keep record of token collateral (tez/token)
type vaultType is [@layout:comb] record [
    address                     : address;
    collateralBalanceLedger     : collateralBalanceLedgerType;   // tez/token balance
    usdmOutstanding             : usdmAmountType;                // nat     
    lastMintBlockLevel          : nat;                           // block level of when USDM was last minted
]

// owner types
type ownerVaultSetType              is set(vaultIdType)                     // set of vault ids belonging to the owner 
type ownerLedgerType                is big_map(address, ownerVaultSetType)  // big map of owners, and the corresponding vaults they own
type vaultLedgerType                is big_map(vaultIdType, bool);

// price and token types
type targetLedgerType               is map(string, nat)
type driftLedgerType                is map(string, int)
type lastDriftUpdateLedgerType      is map(string, timestamp)
type cfmmAddressLedgerType          is map(string, address)
type priceLedgerType                is map(string, nat)

// ------------------------------------------------------------------------------

// oracle view for getting last completed round price
type lastCompletedRoundPriceReturnType is [@layout:comb] record [
    round: nat;
    price: nat;
    percentOracleResponse: nat;
    decimals: nat;
]

// ----- types for entrypoint actions begin -----

type setUsdmAddressActionType is [@layout:comb] record [
    usdmTokenAddress            : address; 
]

type updateCfmmAddressLedgerActionType is [@layout:comb] record [
    tokenName                   : string;
    cfmmAddress                 : address;
]

type updateCollateralTokenLedgerActionType is [@layout:comb] record [
    tokenName                   : string;
    tokenContractAddress        : address;
    tokenType                   : tokenType;
    decimals                    : nat;
    oracleType                  : string;
    oracleAddress               : address;
]

type updateVaultTokenAddressesActionType is [@layout:comb] record [
    handle                      : vaultHandleType; 
]

type tokenAmountLedgerType is map(string, tokenAmountType)

type createVaultActionType is [@layout:comb] record [
    delegate                    : option(key_hash); 
    depositors                  : depositorsType;
]

type closeVaultActionType is [@layout:comb] record [
    vaultId                     : vaultIdType; 
]

type withdrawFromVaultActionType is [@layout:comb] record [
    id                          : vaultIdType; 
    tokenAmount                 : nat;  
    tokenName                   : string;
    // [@annot:to] to_             : contract(unit);
]

type liquidateVaultActionType is [@layout:comb] record [
    handle                      : vaultHandleType; 
    usdmQuantity                : nat; 
    [@annot:to] to_             : contract(unit);
]

type mintOrBurnActionType is [@layout:comb] record [ 
    id          : nat; 
    quantity    : int;
]

type onPriceActionType is [@layout:comb] record [ 
    tokenName     : string;
    cashAmount    : nat; 
    tokenAmount   : nat; 
]

type registerDepositType is [@layout:comb] record [
    handle      : vaultHandleType; 
    amount      : nat;
    tokenName   : string;
]

type configType is [@layout:comb] record [
    collateralRatio           : nat;    // collateral ratio
    liquidationRatio          : nat;    // liquidation ratio
    
    liquidationFee            : nat;    // liquidation fee - penalty fee paid by vault owner to liquidator
    adminLiquidationFee       : nat;    // admin liquidation fee - penalty fee paid by vault owner to treasury

    minimumLoanFee            : nat;    // minimum loan fee - taken at first minting
    annualServiceLoanFee      : nat;    // annual service loan fee - compounding over time    
    dailyServiceLoanFee       : nat;    // daily service loan fee - compounding over time (annualServiceLoanFee / 365)
    blocksPerMinute           : nat; 

    decimals                  : nat;    // decimals 
]

type getTargetActionType is [@layout:comb] record [
    tokenName           : string;
    callbackContract    : contract(nat);
]


// ------------------------------------------------------------------------------
// Storage
// ------------------------------------------------------------------------------

type controllerStorage is [@layout:comb] record [
    admin                       : address;
    config                      : configType;
    
    usdmTokenAddress            : address;                // USDM token contract address
    generalContracts            : generalContractsType;
    whitelistTokenContracts     : whitelistTokenContractsType;      

    // vaults and owners
    vaults                      : big_map(vaultHandleType, vaultType);
    vaultCounter                : vaultIdType;      // nat
    vaultLedger                 : vaultLedgerType;  // used to check if vault id is in use already
    ownerLedger                 : ownerLedgerType;  // for some convenience in checking vaults owned by user

    // price, tokens and cfmm
    targetLedger                : targetLedgerType;
    driftLedger                 : driftLedgerType;
    lastDriftUpdateLedger       : lastDriftUpdateLedgerType;
    collateralTokenLedger       : collateralTokenLedgerType;
    priceLedger                 : priceLedgerType;
    cfmmAddressLedger           : cfmmAddressLedgerType;  // map of CFMM addresss providing the price feed

    tempValue                   : nat;
]

type controllerAction is 
    | Default of unit

    | UpdateGeneralContracts         of updateGeneralContractsParams
    | UpdateWhitelistTokenContracts  of updateWhitelistTokenContractsParams
    | UpdateCollateralTokenLedger    of updateCollateralTokenLedgerActionType
    | UpdateCfmmAddressLedger        of updateCfmmAddressLedgerActionType
    | SetUsdmAddress                 of setUsdmAddressActionType

    | CreateVault                    of createVaultActionType
    | CloseVault                     of closeVaultActionType
    | LiquidateVault                 of liquidateVaultActionType
    | WithdrawFromVault              of withdrawFromVaultActionType
    | RegisterDeposit                of registerDepositType
    | MintOrBurn                     of mintOrBurnActionType

      // Staked MVK Entrypoints   
    | VaultDepositStakedMvk          of vaultDepositStakedMvkType   
    | VaultWithdrawStakedMvk         of vaultWithdrawStakedMvkType   
    | VaultLiquidateStakedMvk        of vaultLiquidateStakedMvkType   
    
    | OnPriceAction                  of onPriceActionType
    | GetTarget                      of getTargetActionType

const noOperations : list (operation) = nil;
type return is list (operation) * controllerStorage


// ----- constants begin -----

const zeroAddress            : address  = ("tz1ZZZZZZZZZZZZZZZZZZZZZZZZZZZZNkiRg":address);
const fixedPointAccuracy     : nat      = 1_000_000_000_000_000_000_000_000n;   // 10^24     - // for use in division
// const tezFixedPointAccuracy  : nat      = 1_000_000_000_000_000_000n;           // 10^18    - // for use in division with tez
const tezFixedPointAccuracy  : nat      = 1_000_000_000_000_000_000_000_000_000n;           // 10^27    - // for use in division with tez

// for use in division from oracle where price decimals may vary
const fpa10e27 : nat = 1_000_000_000_000_000_000_000_000_000n;   // 10^27 
const fpa10e26 : nat = 1_000_000_000_000_000_000_000_000_00n;    // 10^26
const fpa10e25 : nat = 1_000_000_000_000_000_000_000_000_0n;     // 10^25
const fpa10e24 : nat = 1_000_000_000_000_000_000_000_000n;       // 10^24
const fpa10e23 : nat = 1_000_000_000_000_000_000_000_00n;        // 10^23
const fpa10e22 : nat = 1_000_000_000_000_000_000_000_0n;         // 10^22
const fpa10e21 : nat = 1_000_000_000_000_000_000_000n;           // 10^21

const fpa10e15 : nat = 1_000_000_000_000_000n;           // 10^15
const fpa10e14 : nat = 1_000_000_000_000_00n;            // 10^14
const fpa10e13 : nat = 1_000_000_000_000_0n;             // 10^13
const fpa10e12 : nat = 1_000_000_000_000n;               // 10^12
const fpa10e11 : nat = 1_000_000_000_00n;                // 10^11
const fpa10e10 : nat = 1_000_000_000_0n;                 // 10^10
const fpa10e9 : nat = 1_000_000_000n;                    // 10^9
const fpa10e8 : nat = 1_000_000_00n;                     // 10^8
const fpa10e7 : nat = 1_000_000_0n;                      // 10^7
const fpa10e6 : nat = 1_000_000n;                        // 10^6
const fpa10e5 : nat = 1_000_00n;                         // 10^5
const fpa10e4 : nat = 1_000_0n;                          // 10^4
const fpa10e3 : nat = 1_000n;                            // 10^3

// ----- constants end -----


// multi-asset vault
#include "u_vault.ligo"

// helper functions - conversions
function mutezToNatural(const amt : tez) : nat is amt / 1mutez;
function naturalToMutez(const amt : nat) : tez is amt * 1mutez;

// helper function - check sender is admin
function checkSenderIsAdmin(var s : controllerStorage) : unit is
  if (Tezos.get_sender() = s.admin) then unit
  else failwith("Error. Only the administrator can call this entrypoint.");



function checkSenderIsSelf(const _p : unit) : unit is
    if (Tezos.get_sender() = Tezos.get_self_address()) then unit
    else failwith("Error. Only self is allowed");



function checkZeroUsdmOutstanding(const vault : vaultType) : unit is
  if vault.usdmOutstanding = 0n then unit
  else failwith("Error. USDM Outstanding is not zero.")



// helper function to get vaultWithdraw entrypoint
function getVaultWithdrawEntrypoint(const vaultAddress : address) : contract(vaultWithdrawType) is
  case (Tezos.get_entrypoint_opt(
      "%vaultWithdraw",
      vaultAddress) : option(contract(vaultWithdrawType))) of [
    Some(contr) -> contr
  | None -> (failwith("Error. VaultWithdraw entrypoint in vault not found") : contract(vaultWithdrawType))
  ]

// helper function to get vaultDelegateTez entrypoint
function getVaultDelegateTezEntrypoint(const vaultAddress : address) : contract(vaultDelegateTezToBakerType) is
  case (Tezos.get_entrypoint_opt(
      "%vaultDelegateTezToBaker",
      vaultAddress) : option(contract(vaultDelegateTezToBakerType))) of [
    Some(contr) -> contr
  | None -> (failwith("Error. vaultDelegateTezToBaker entrypoint in vault not found") : contract(vaultDelegateTezToBakerType))
  ]



// helper function to get mintOrBurn entrypoint from USDM Token contract
function getUsdmMintOrBurnEntrypoint(const tokenContractAddress : address) : contract(mintOrBurnParamsType) is
  case (Tezos.get_entrypoint_opt(
      "%mintOrBurn",
      tokenContractAddress) : option(contract(mintOrBurnParamsType))) of [
    Some(contr) -> contr
  | None -> (failwith("Error. MintOrBurn entrypoint in token contract not found") : contract(mintOrBurnParamsType))
  ]


// helper function to get vaultDepositStakedMvk entrypoint from doorman contract
function getVaultDepositStakedMvkEntrypoint(const contractAddress : address) : contract(vaultDepositStakedMvkType) is
  case (Tezos.get_entrypoint_opt(
      "%vaultDepositStakedMvk",
      contractAddress) : option(contract(vaultDepositStakedMvkType))) of [
    Some(contr) -> contr
  | None -> (failwith("Error. vaultDepositStakedMvk entrypoint in contract not found") : contract(vaultDepositStakedMvkType))
  ]


// helper function to get vaultWithdrawStakedMvk entrypoint from doorman contract
function getVaultWithdrawStakedMvkEntrypoint(const contractAddress : address) : contract(vaultWithdrawStakedMvkType) is
  case (Tezos.get_entrypoint_opt(
      "%vaultWithdrawStakedMvk",
      contractAddress) : option(contract(vaultWithdrawStakedMvkType))) of [
    Some(contr) -> contr
  | None -> (failwith("Error. vaultWithdrawStakedMvk entrypoint in contract not found") : contract(vaultWithdrawStakedMvkType))
  ]

// helper function to get vaultLiquidateStakedMvk entrypoint from doorman contract
function getVaultLiquidateStakedMvkEntrypoint(const contractAddress : address) : contract(vaultLiquidateStakedMvkType) is
  case (Tezos.get_entrypoint_opt(
      "%vaultLiquidateStakedMvk",
      contractAddress) : option(contract(vaultLiquidateStakedMvkType))) of [
    Some(contr) -> contr
  | None -> (failwith("Error. vaultLiquidateStakedMvk entrypoint in contract not found") : contract(vaultLiquidateStakedMvkType))
  ]



function transferTez(const to_ : contract(unit); const amt : nat) : operation is Tezos.transaction(unit, amt * 1mutez, to_)

// helper function to transfer FA12 tokens
function transferFa12Token(const from_: address; const to_: address; const tokenAmount: tokenAmountType; const tokenContractAddress: address): operation is
    block{
        const transferParams: fa12TransferType = (from_,(to_,tokenAmount));

        const tokenContract: contract(fa12TransferType) =
            case (Tezos.get_entrypoint_opt("%transfer", tokenContractAddress): option(contract(fa12TransferType))) of [
                Some (c) -> c
            |   None -> (failwith("Error. Transfer entrypoint not found in FA12 Token contract"): contract(fa12TransferType))
            ];
    } with (Tezos.transaction(transferParams, 0tez, tokenContract))

// helper function to transfer FA2 tokens
function transferFa2Token(const from_: address; const to_: address; const tokenAmount: tokenAmountType; const tokenId: nat; const tokenContractAddress: address): operation is
block{
    const transferParams: fa2TransferType = list[
            record[
                from_ = from_;
                txs = list[
                    record[
                        to_      = to_;
                        token_id = tokenId;
                        amount   = tokenAmount;
                    ]
                ]
            ]
        ];

    const tokenContract: contract(fa2TransferType) =
        case (Tezos.get_entrypoint_opt("%transfer", tokenContractAddress): option(contract(fa2TransferType))) of [
            Some (c) -> c
        |   None -> (failwith("Error. Transfer entrypoint not found in FA2 Token contract"): contract(fa2TransferType))
        ];

} with (Tezos.transaction(transferParams, 0tez, tokenContract))




// Whitelist Token Contracts: checkInWhitelistTokenContracts, updateWhitelistTokenContracts - cannot include as storage type is different
function checkInWhitelistTokenContracts(const contractAddress : address; var s : controllerStorage) : bool is 
block {
  var inWhitelistTokenContractsMap : bool := False;
  for _key -> value in map s.whitelistTokenContracts block {
    if contractAddress = value then inWhitelistTokenContractsMap := True
      else skip;
  }  
} with inWhitelistTokenContractsMap



(* UpdateWhitelistTokenContracts Entrypoint *)
function updateWhitelistTokenContracts(const updateWhitelistTokenContractsParams: updateWhitelistTokenContractsParams; var s : controllerStorage) : return is 
  block{

    checkSenderIsAdmin(s); // check that sender is admin

    const contractName     : string  = updateWhitelistTokenContractsParams.tokenContractName;
    const contractAddress  : address = updateWhitelistTokenContractsParams.tokenContractAddress;
    
    const existingAddress: option(address) = 
      if checkInWhitelistTokenContracts(contractAddress, s) then (None : option(address)) else Some (contractAddress);

    const updatedWhitelistTokenContracts: whitelistTokenContractsType = 
      Map.update(
        contractName, 
        existingAddress,
        s.whitelistTokenContracts
      );

    s.whitelistTokenContracts := updatedWhitelistTokenContracts

  } with (noOperations, s) 


// General Contracts: checkInGeneralContracts, updateGeneralContracts
#include "../partials/generalContractsMethod.ligo"



  // CFMM Address Ledger
function checkInCfmmAddressLedger(const cfmmAddress : address; var s : controllerStorage) : bool is 
block {
  var inCfmmAddressLedgerMap : bool := False;
  for _key -> value in map s.cfmmAddressLedger block {
    if cfmmAddress = value then inCfmmAddressLedgerMap := True
      else skip;
  }  
} with inCfmmAddressLedgerMap



(* UpdateWhitelistTokenContracts Entrypoint *)
function updateCfmmAddressLedger(const updateCfmmAddressLedgerParams: updateCfmmAddressLedgerActionType; var s : controllerStorage) : return is 
  block{

    checkSenderIsAdmin(s); // check that sender is admin

    const tokenName     : string  = updateCfmmAddressLedgerParams.tokenName;
    const cfmmAddress   : address = updateCfmmAddressLedgerParams.cfmmAddress;
    
    const existingAddress: option(address) = 
      if checkInCfmmAddressLedger(cfmmAddress, s) then (None : option(address)) else Some (cfmmAddress);

    const updatedCfmmAddressLedger: whitelistTokenContractsType = 
      Map.update(
        tokenName, 
        existingAddress,
        s.cfmmAddressLedger
      );

    s.cfmmAddressLedger := updatedCfmmAddressLedger

  } with (noOperations, s) 



(* View: get token in collateral token ledger *)
[@view] function viewGetTokenRecordByName(const tokenName : string; var s : controllerStorage) : option(collateralTokenRecordType) is
    Map.find_opt(tokenName, s.collateralTokenLedger)



(* View: get token by token contract address in collateral token ledger *)
[@view] function viewGetTokenRecordByAddress(const tokenContractAddress : address; var s : controllerStorage) : option(collateralTokenRecordType) is
block {

  var tokenName : string := "empty";
  
  for _key -> value in map s.collateralTokenLedger block {
    if tokenContractAddress = value.tokenContractAddress then block {
        tokenName := _key;
    } else skip;
  };

  const collateralTokenRecord : option(collateralTokenRecordType) = Map.find_opt(tokenName, s.collateralTokenLedger)

} with collateralTokenRecord



(* View: get owned vaults by user *)
[@view] function getOwnedVaultsByUserOpt(const ownerAddress : address; var s : controllerStorage) : option(ownerVaultSetType) is
    Big_map.find_opt(ownerAddress, s.ownerLedger)



(* View: get vault by handle *)
[@view] function getVaultOpt(const vaultHandle : vaultHandleType; var s : controllerStorage) : option(vaultType) is
    Big_map.find_opt(vaultHandle, s.vaults)



(* View: get contract address - e.g. find delegation address to pass to vault for delegating MVK to satellite  *)
[@view] function getContractAddressOpt(const contractName : string; var s : controllerStorage) : option(address) is
    Map.find_opt(contractName, s.generalContracts)



function checkInCollateralTokenLedger(const collateralTokenRecord : collateralTokenRecordType; var s : controllerStorage) : bool is 
block {
  var inCollateralTokenLedgerBool : bool := False;
  for _key -> value in map s.collateralTokenLedger block {
    if collateralTokenRecord = value then inCollateralTokenLedgerBool := True
      else skip;
  }  
} with inCollateralTokenLedgerBool


(*  updateGeneralContracts entrypoint *)
function updateGeneralContracts(const updateGeneralContractsParams: updateGeneralContractsParams; var s: controllerStorage): return is
block {

    checkSenderIsAdmin(s);

    s.generalContracts := updateGeneralContractsMap(updateGeneralContractsParams, s.generalContracts);

} with (noOperations, s)



(* UpdateCollateralTokenLedger Entrypoint *)
function updateCollateralTokenLedger(const updateCollateralTokenLedgerParams: updateCollateralTokenLedgerActionType; var s : controllerStorage) : return is 
  block{

    checkSenderIsAdmin(s); // check that sender is admin

    const tokenName             : string      = updateCollateralTokenLedgerParams.tokenName;
    const tokenContractAddress  : address     = updateCollateralTokenLedgerParams.tokenContractAddress;
    const tokenType             : tokenType   = updateCollateralTokenLedgerParams.tokenType;
    const decimals              : nat         = updateCollateralTokenLedgerParams.decimals;
    const oracleType            : string      = updateCollateralTokenLedgerParams.oracleType;
    var oracleAddress         : address       := updateCollateralTokenLedgerParams.oracleAddress;

    if oracleType = "cfmm" then block {
        oracleAddress := zeroAddress;
    } else skip;
    
    const collateralTokenRecord : collateralTokenRecordType = record [
        tokenName            = tokenName;
        tokenContractAddress = tokenContractAddress;
        tokenType            = tokenType;
        decimals             = decimals;
        oracleType           = oracleType;
        oracleAddress        = oracleAddress;
    ];

    const existingToken: option(collateralTokenRecordType) = 
      if checkInCollateralTokenLedger(collateralTokenRecord, s) then (None : option(collateralTokenRecordType)) else Some (collateralTokenRecord);

    const updatedCollateralTokenLedger : collateralTokenLedgerType = 
      Map.update(
        tokenName, 
        existingToken,
        s.collateralTokenLedger
      );

    s.collateralTokenLedger := updatedCollateralTokenLedger

  } with (noOperations, s) 

  

// helper function to create vault 
type createVaultFuncType is (option(key_hash) * tez * vaultStorage) -> (operation * address)
const createVaultFunc : createVaultFuncType =
[%Michelson ( {| { UNPPAIIR ;
                  CREATE_CONTRACT
#include "../compiled/u_vault.tz"
        ;
          PAIR } |}
: createVaultFuncType)];


// helper function to get vault
function getVault(const handle : vaultHandleType; var s : controllerStorage) : vaultType is 
block {
    var vault : vaultType := case s.vaults[handle] of [
        Some(_vault) -> _vault
        | None -> failwith("Error. Vault not found.")
    ];
} with vault



// helper function to check if vault is under collaterized
function isUnderCollaterized(const vault : vaultType; var s : controllerStorage) : bool is 
block {
    
    // initialise variables - vaultCollateralValue and usdmOutstanding
    var vaultCollateralValueInUsd   : nat  := 0n;
    const usdmOutstanding           : nat  = vault.usdmOutstanding;    
    const liquidationRatio          : nat  = s.config.liquidationRatio;  // default 3000n: i.e. 3x - 2.25x - 2250

    for tokenName -> tokenBalance in map vault.collateralBalanceLedger block {
        
        const collateralTokenRecord : collateralTokenRecordType = case s.collateralTokenLedger[tokenName] of [
                Some(_record) -> _record
            | None -> failwith("Error. Token does not exist in collateral token record.")
        ];

        // get last completed round price of token from Oracle view
        const getTokenLastCompletedRoundPriceView : option (option(lastCompletedRoundPriceReturnType)) = Tezos.call_view ("lastCompletedRoundPrice", unit, collateralTokenRecord.oracleAddress);
        const getTokenLastCompletedRoundPriceOpt: option(lastCompletedRoundPriceReturnType) = case getTokenLastCompletedRoundPriceView of [
                Some (_value) -> _value
            | None -> failwith ("Error. lastCompletedRoundPrice View not found in the Oracle Contract.")
        ];
        const tokenLastCompletedRoundPrice: lastCompletedRoundPriceReturnType = case getTokenLastCompletedRoundPriceOpt of [
                Some (_value) -> _value
            | None -> failwith ("Error. lastCompletedRoundPrice not found.")
        ];

        // todo: check decimals and percentOracleResponse
        // todo: ensure exponent is standardized
        // denomination in USD 
        
        const tokenDecimals    : nat  = collateralTokenRecord.decimals; 
        const priceDecimals    : nat  = tokenLastCompletedRoundPrice.decimals;

        // calculate required number of decimals to rebase each token to the same unit for comparison
        // assuming most token decimals are 6, and most price decimals from oracle is 8 - set upper limit of 24 (e.g. 12 decimals each)
        if tokenDecimals + priceDecimals > 24n then failwith("Error. Too many decimals for token * price.") else skip;
        const rebaseDecimals   : nat  = abs(24n - (tokenDecimals + priceDecimals));

        const tokenPrice       : nat  = tokenLastCompletedRoundPrice.price;            

        // calculate value of collateral balance
        var tokenValueInUsd : nat := tokenBalance * tokenPrice;

        if rebaseDecimals = 1n then 
            tokenValueInUsd := tokenValueInUsd * 10n
        else if rebaseDecimals = 2n then 
            tokenValueInUsd := tokenValueInUsd * 100n 
        else if rebaseDecimals = 3n then 
            tokenValueInUsd := tokenValueInUsd * 1000n 
        else if rebaseDecimals = 4n then 
            tokenValueInUsd := tokenValueInUsd * fpa10e4 
        else if rebaseDecimals = 5n then 
            tokenValueInUsd := tokenValueInUsd * fpa10e5
        else if rebaseDecimals = 6n then 
            tokenValueInUsd := tokenValueInUsd * fpa10e6
        else if rebaseDecimals = 7n then 
            tokenValueInUsd := tokenValueInUsd * fpa10e7
        else if rebaseDecimals = 8n then 
            tokenValueInUsd := tokenValueInUsd * fpa10e8
        else if rebaseDecimals = 9n then 
            tokenValueInUsd := tokenValueInUsd * fpa10e9
        else if rebaseDecimals = 10n then 
            tokenValueInUsd := tokenValueInUsd * fpa10e10
        else if rebaseDecimals = 11n then 
            tokenValueInUsd := tokenValueInUsd * fpa10e11
        else if rebaseDecimals = 12n then 
            tokenValueInUsd := tokenValueInUsd * fpa10e12
        else if rebaseDecimals = 13n then 
            tokenValueInUsd := tokenValueInUsd * fpa10e13
        else if rebaseDecimals = 14n then 
            tokenValueInUsd := tokenValueInUsd * fpa10e14
        else if rebaseDecimals = 15n then 
            tokenValueInUsd := tokenValueInUsd * fpa10e15
        else skip;
            
        // increment vault collateral value - value should have a base decimal of 1e24
        vaultCollateralValueInUsd := vaultCollateralValueInUsd + tokenValueInUsd;

    };

    // usdmOutstanding will be 1e9 (token decimals), so multiply by 1e15 to have a base of 1e24
    const usdmOutstandingRebased : nat = usdmOutstanding * fpa10e15; 

    // check is vault is under collaterized based on liquidation ratio
    const isUnderCollaterized : bool = vaultCollateralValueInUsd < (liquidationRatio * usdmOutstandingRebased) / 1000n;
    
    // old code
    // const isUnderCollaterized : bool  = (15n * vault.collateralBalance) < (Bitwise.shift_right (vault.usdmOutstanding * s.target, 44n)); 

} with isUnderCollaterized




(* setUsdmAddress entrypoint *)
function setUsdmAddress(const setUsdmAddressParams : setUsdmAddressActionType; var s : controllerStorage) : return is
block {

    // check that sender is admin
    checkSenderIsAdmin(s);

    // set usdmTokenAddress and cfmmAddress if they have not been set, otherwise fail 
    // (i.e. they can only be set once after contract origination)
    if s.usdmTokenAddress =/= ("tz1Ke2h7sDdakHJQh8WX4Z372du1KChsksyU" : address) then 
        failwith("Error. usdmTokenAddress is already set.")
    else block {
        s.usdmTokenAddress := setUsdmAddressParams.usdmTokenAddress;
    }

} with (noOperations, s)



(* createVault entrypoint *)
function createVault(const createParams : createVaultActionType ; var s : controllerStorage) : return is 
block {
    
    // change from ctez with inclusion of a vault counter
    
    // get vault counter
    const newVaultId : vaultIdType = s.vaultCounter;
    
    // check if vault id already exists
    if Big_map.mem(newVaultId, s.vaultLedger) then failwith("Error. Vault Id already exists.") else skip;
    
    // make vault handle
    const handle : vaultHandleType = record [
        id     = newVaultId;
        owner  = Tezos.get_sender();
    ];

    // check if vault already exists
    if Big_map.mem(handle, s.vaults) then failwith("Error. Vault already exists.") else skip;

    // init operations
    var operations : list(operation) := nil;

    // params for vault with tez storage origination
    const originateVaultStorage : vaultStorage = record [
        admin                       = Tezos.get_self_address();
        handle                      = handle;
        depositors                  = createParams.depositors;
    ];

    // originate vault func
    const vaultOrigination : (operation * address) = createVaultFunc(
        (None : option(key_hash)), 
        Tezos.get_amount(),
        originateVaultStorage
    );

    // add vaultWithTezOrigination operation to operations list
    operations := vaultOrigination.0 # operations; 

    // create new vault params
    if mutezToNatural(Tezos.get_amount()) > 0n then block {
        
        // tez is sent
        const collateralBalanceLedgerMap : collateralBalanceLedgerType = map[
            ("tez" : string) -> mutezToNatural(Tezos.get_amount())
        ];
        const vault : vaultType = record [
            address                    = vaultOrigination.1; // vault address
            collateralBalanceLedger    = collateralBalanceLedgerMap;
            usdmOutstanding            = 0n;
            lastMintBlockLevel         = Tezos.get_level();
        ];
        
        // update controller storage with new vault
        s.vaults := Big_map.update(handle, Some(vault), s.vaults);

    } else block {
        // no tez is sent
        const emptyCollateralBalanceLedgerMap : collateralBalanceLedgerType = map[];
        const vault : vaultType = record [
            address                    = vaultOrigination.1; // vault address
            collateralBalanceLedger    = emptyCollateralBalanceLedgerMap;
            usdmOutstanding            = 0n;
            lastMintBlockLevel         = Tezos.get_level();
        ];

        // update controller storage with new vault
        s.vaults := Big_map.update(handle, Some(vault), s.vaults);

    };

    // increment vault counter and add vault id to vaultLedger
    s.vaultLedger[newVaultId] := True;
    s.vaultCounter            := s.vaultCounter + 1n;

} with (operations, s)



(* closeVault entrypoint *)
function closeVault(const closeVaultParams : closeVaultActionType ; var s : controllerStorage) : return is 
block {
    
    // only the vault owner can close his own vault

    // init parameters 
    const vaultId     : vaultIdType      = closeVaultParams.vaultId;
    const vaultOwner  : vaultOwnerType   = Tezos.get_sender();
    var operations    : list(operation) := nil;
    
    // make vault handle
    const vaultHandle : vaultHandleType = record [
        id     = vaultId;
        owner  = vaultOwner;
    ];

    // get vault
    var _vault : vaultType := getVault(vaultHandle, s);
    const vaultAddress : address = _vault.address;

    // check that vault has zero USDM oustanding
    checkZeroUsdmOutstanding(_vault);

    // get tokens and token balances and initiate transfer back to the vault owner
    for tokenName -> tokenBalance in map _vault.collateralBalanceLedger block {
        
        if tokenName = "tez" then block {

            const transferTezOperation : operation = transferTez( (Tezos.get_contract_with_error(vaultOwner, "Error. Unable to send tez.") : contract(unit)), tokenBalance );
            operations := transferTezOperation # operations;

            _vault.collateralBalanceLedger[tokenName]  := 0n;
            
        } else block {

            const collateralTokenRecord : collateralTokenRecordType = case s.collateralTokenLedger[tokenName] of [
                  Some(_record) -> _record
                | None -> failwith("Error. Token does not exist in collateral token record.")
            ];

            if collateralTokenRecord.tokenName = "sMVK" then block {

                // for special case of sMVK

                // create operation to doorman to withdraw all staked MVK from vault to user
                const vaultWithdrawStakedMvkParams : vaultWithdrawStakedMvkType = record [
                    vaultId         = vaultId;
                    withdrawAmount  = collateralTokenRecord.balance;
                ];
                const vaultWithdrawAllStakedMvkOperation : operation = Tezos.transaction(
                    vaultWithdrawStakedMvkParams,
                    0tez,
                    getVaultWithdrawStakedMvkEntrypoint(doormanAddress)
                );
                operations := vaultWithdrawAllStakedMvkOperation # operations;

            } else block {

                // for other collateral token types besides sMVK

                const withdrawTokenOperation : operation = case collateralTokenRecord.tokenType of [
                    Tez(_tez) -> block {
                        
                        const withdrawTezOperationParams : vaultWithdrawType = record [
                            from_ = vaultAddress;
                            to_   = vaultOwner; 
                            amt   = tokenBalance;
                            token = Tez(_tez);
                        ];
                        const withdrawTezOperation : operation = Tezos.transaction(
                            withdrawTezOperationParams,
                            0mutez,
                            getVaultWithdrawEntrypoint(vaultAddress)
                        );

                    } with withdrawTezOperation
                    | Fa12(_token) -> block {

                        const withdrawFa12OperationParams : vaultWithdrawType = record [
                            from_ = vaultAddress;
                            to_   = vaultOwner; 
                            amt   = tokenBalance;
                            token = Fa12(_token);
                        ];
                        const withdrawFa12Operation : operation = Tezos.transaction(
                            withdrawFa12OperationParams,
                            0mutez,
                            getVaultWithdrawEntrypoint(vaultAddress)
                        );

                    } with withdrawFa12Operation
                    | Fa2(_token) -> block {

                        const withdrawFa2OperationParams : vaultWithdrawType = record [
                            from_ = vaultAddress;
                            to_   = vaultOwner; 
                            amt   = tokenBalance;
                            token = Fa2(_token);
                        ];
                        const withdrawFa2Operation : operation = Tezos.transaction(
                            withdrawFa2OperationParams,
                            0mutez,
                            getVaultWithdrawEntrypoint(vaultAddress)
                        );

                    } with withdrawFa2Operation
                ];

                operations := withdrawTokenOperation # operations;
            };

            // save and update balance for collateral token to zero
            _vault.collateralBalanceLedger[tokenName]  := 0n;

        }; // end if/else check for tez/token

    }; // end loop for withdraw operations of tez/tokens in vault collateral 


    // remove vault from stroage
    var ownerVaultSet : ownerVaultSetType := case s.ownerLedger[vaultOwner] of [
          Some (_set) -> _set
        | None        -> failwith("Error. Owner vault set not found.")
    ];
    s.ownerLedger[vaultOwner] := Set.remove(vaultId, ownerVaultSet);
    remove vaultHandle from map s.vaults;
    remove vaultId from map s.vaultLedger;
    
} with (operations, s)




(* withdrawFromVault entrypoint *)
function withdrawFromVault(const withdrawParams : withdrawFromVaultActionType; var s : controllerStorage) : return is 
block {

    // init variables for convenience
    const vaultId                : vaultIdType       = withdrawParams.id; 
    const withdrawTokenAmount    : nat               = withdrawParams.tokenAmount;
    const tokenName              : string            = withdrawParams.tokenName;
    // const recipient              : contract(unit)    = withdrawParams.to_;
    const recipient              : address           = Tezos.get_sender();
    const initiator              : vaultOwnerType    = Tezos.get_sender();
    var operations               : list(operation)  := nil;

    // make vault handle
    const vaultHandle : vaultHandleType = record [
        id     = vaultId;
        owner  = initiator;
    ];

    // get vault
    var vault : vaultType := getVault(vaultHandle, s);

    // if tez is to be withdrawn, check that Tezos amount should be the same as withdraw amount
    if tokenName = "tez" then block {
        if mutezToNatural(Tezos.get_amount()) =/= withdrawTokenAmount then failwith("Error. Tezos amount and withdraw token amount do not match.") else skip;
    } else skip;

    // get token collateral balance in vault, fail if none found
    var vaultTokenCollateralBalance : nat := case vault.collateralBalanceLedger[tokenName] of [
          Some(_balance) -> _balance
        | None -> failwith("Error. You do not have any tokens to withdraw.")
    ];

    // calculate new vault balance
    if withdrawTokenAmount > vaultTokenCollateralBalance then failwith("Error. Token withdrawal amount cannot be greater than your collateral balance.") else skip;
    const newCollateralBalance : nat  = abs(vaultTokenCollateralBalance - withdrawTokenAmount);

    // check if vault is undercollaterized, if not then send withdraw operation
    if isUnderCollaterized(vault, s) 
    then failwith("Error. Withdrawal is not allowed as vault is undercollaterized.") 
    else skip;
    
    // get collateral token record - with token contract address and token type
    const collateralTokenRecord : collateralTokenRecordType = case s.collateralTokenLedger[tokenName] of [
          Some(_collateralTokenRecord) -> _collateralTokenRecord
        | None -> failwith("Error. Collateral Token Record not found in collateral token ledger.")
    ];

    // pattern match withdraw operation based on token type
    const withdrawOperation : operation = case collateralTokenRecord.tokenType of [
        
        Tez(_tez) -> block {
            
            const withdrawTezOperationParams : vaultWithdrawType = record [
                from_ = vault.address;
                to_   = recipient; 
                amt   = withdrawTokenAmount;
                token = Tez(_tez);
            ];
            const withdrawTezOperation : operation = Tezos.transaction(
                withdrawTezOperationParams,
                0mutez,
                getVaultWithdrawEntrypoint(vault.address)
            );

        } with withdrawTezOperation

        | Fa12(_token) -> block {

            const withdrawFa12OperationParams : vaultWithdrawType = record [
                from_ = vault.address;
                to_   = recipient; 
                amt   = withdrawTokenAmount;
                token = Fa12(_token);
            ];
            const withdrawFa12Operation : operation = Tezos.transaction(
                withdrawFa12OperationParams,
                0mutez,
                getVaultWithdrawEntrypoint(vault.address)
            );

        } with withdrawFa12Operation

        | Fa2(_token) -> block {

            const withdrawFa2OperationParams : vaultWithdrawType = record [
                from_ = vault.address;
                to_   = recipient; 
                amt   = withdrawTokenAmount;
                token = Fa2(_token);
            ];
            const withdrawFa2Operation : operation = Tezos.transaction(
                withdrawFa2OperationParams,
                0mutez,
                getVaultWithdrawEntrypoint(vault.address)
            );

        } with withdrawFa2Operation

    ];

    operations := withdrawOperation # operations;

    // save and update new balance for collateral token
    vault.collateralBalanceLedger[tokenName] := newCollateralBalance;
    s.vaults[vaultHandle]                     := vault;

} with (operations, s)




(* registerDeposit entrypoint *)
function registerDeposit(const registerDepositParams : registerDepositType; var s : controllerStorage) : return is 
block {

    // init variables for convenience
    const vaultHandle     : vaultHandleType   = registerDepositParams.handle;
    const depositAmount   : nat               = registerDepositParams.amount;
    const tokenName       : string            = registerDepositParams.tokenName;

    const initiator       : address           = Tezos.get_sender(); // vault address that initiated deposit

    // check if token exists in collateral token ledger
    const _collateralTokenRecord : collateralTokenRecordType = case s.collateralTokenLedger[tokenName] of [
          Some(_record) -> _record
        | None -> failwith("Error. Collateral Token Record not found in collateralTokenLedger.")
    ];

    // get vault
    var vault : vaultType := getVault(vaultHandle, s);

    // check if sender matches vault owner; if match, then update and save vault with new collateral balance
    if vault.address =/= initiator then failwith("Error. Sender does not match vault owner address.") else skip;
    
    // get token collateral balance in vault, set to 0n if not found in vault (i.e. first deposit)
    var vaultTokenCollateralBalance : nat := case vault.collateralBalanceLedger[tokenName] of [
          Some(_balance) -> _balance
        | None -> 0n
    ];

    // calculate new collateral balance
    const newCollateralBalance : nat = vaultTokenCollateralBalance + depositAmount;

    // save and update new balance for collateral token
    vault.collateralBalanceLedger[tokenName]  := newCollateralBalance;
    s.vaults[vaultHandle]                     := vault;

} with (noOperations, s)




(* liquidateVault entrypoint *)
function liquidateVault(const liquidateParams : liquidateVaultActionType; var s : controllerStorage) : return is 
block {
    
    // init variables for convenience
    const vaultHandle       : vaultHandleType         = liquidateParams.handle; 
    const usdmQuantity      : nat                     = liquidateParams.usdmQuantity;

    const recipient         : address                 = Tezos.get_sender();
    const initiator         : initiatorAddressType    = Tezos.get_sender();
    
    var operations          : list(operation)        := nil;

    const liquidationFee        : nat  = s.config.liquidationFee;       // liquidation fee - penalty fee paid by vault owner to liquidator
    const adminLiquidationFee   : nat  = s.config.adminLiquidationFee;  // admin liquidation fee - penalty fee paid by vault owner to treasury

    // get vault
    var _vault : vaultType := getVault(vaultHandle, s);

    // check if vault is under collaterized
    if isUnderCollaterized(_vault, s) 
    then skip 
    else failwith("Error. Vault is not undercollaterized and cannot be liquidated.");

    // check if there is sufficient usdmOutstanding, and calculate remaining usdm after liquidation
    if usdmQuantity > _vault.usdmOutstanding then failwith("Error. Cannot burn more than outstanding amount of USDM in vault.") else skip;
    const remainingUsdm : usdmAmountType = abs(_vault.usdmOutstanding - usdmQuantity);

    // get USDM target
    var usdmTarget : nat  := case s.targetLedger["usdm"] of [
          Some(_nat) -> _nat
        | None -> failwith("Error. Target not found for USDM.")
    ];
    
    // todo: fix extracted balance amount
    (* get 32/31 of the target price, meaning there is a 1/31 penalty (3.23%) for the oven owner for being liquidated *)
    // const totalExtractedBalance : nat = (usdmQuantity * usdmTarget * fixedPointAccuracy) / (31n * fixedPointAccuracy); 

    // usdmQuantity - 1e9 | usdmTarget - 1e24 | fixedPointAccuracy - 1e24
    var totalValueToBeLiquidated           : nat := usdmQuantity * usdmTarget / fixedPointAccuracy;

    // 1e9 * 1e24 * (1e3?) / 1e24
    const liquidationFeeToLiquidator       : nat  = usdmQuantity * usdmTarget * liquidationFee / fixedPointAccuracy; 

    // amount to be sent to treasury
    // 1e9 * 1e24 * (1e3?) / 1e24
    const adminLiquidationFeeToLiquidator  : nat  = usdmQuantity * usdmTarget * adminLiquidationFee / fixedPointAccuracy; 
    
    // total value to be liquidated and sent to liquidator
    totalValueToBeLiquidated := totalValueToBeLiquidated + liquidationFeeToLiquidator;
        
    // get total vault collateral value
    var vaultCollateralValue      : nat := 0n;
    for tokenName -> tokenBalance in map _vault.collateralBalanceLedger block {
        
        if tokenName = "tez" then block {

            // calculate value of tez balance with same fixed point accuracy as price
            const tezValueWithFixedPointAccuracy : nat = tokenBalance * tezFixedPointAccuracy;

            // increment vault collateral value
            vaultCollateralValue := vaultCollateralValue + tezValueWithFixedPointAccuracy;
            
        } else block {

            // get price of token in xtz
            const tokenPrice : nat = case s.priceLedger[tokenName] of [
                  Some(_price) -> _price
                | None         -> failwith("Error. Price not found for token.")
            ];

            // calculate value of collateral balance
            const tokenValueInXtz : nat = tokenBalance * tokenPrice; 

            // increment vault collateral value
            vaultCollateralValue := vaultCollateralValue + tokenValueInXtz;

        };
    };

    
    // loop tokens in vault collateral balance ledger to be liquidated
    var _extractedBalanceTracker   : nat := 0n;
    for tokenName -> tokenBalance in map _vault.collateralBalanceLedger block {

        // skip if token balance is 0n
        if tokenBalance = 0n then skip else block {

            // get collateral token record - with token contract address and token type
            const collateralTokenRecord : collateralTokenRecordType = case s.collateralTokenLedger[tokenName] of [
                  Some(_collateralTokenRecord) -> _collateralTokenRecord
                | None  -> failwith("Error. Collateral Token Record not found in collateral token ledger.")
            ];

            // get price of token in xtz
            const tokenPrice : nat = case s.priceLedger[tokenName] of [
                  Some(_price) -> _price
                | None -> failwith("Error. Price not found for token.")
            ];

            // calculate value of collateral balance
            const tokenValueInXtz : nat = tokenBalance * tokenPrice; 

            // increment extracted balance
            _extractedBalanceTracker := _extractedBalanceTracker + tokenValueInXtz;

            // get proportion of collateral balance against total collateral value
            const tokenProportion : nat = tokenValueInXtz * fixedPointAccuracy / vaultCollateralValue;

            // get balance to be extracted from token
            const tokenProportionalLiquidationValue : nat = tokenProportion * totalValueToBeLiquidated;

            // get quantity of tokens to be liquidated
            const tokenQuantityToBeLiquidated : nat = (tokenProportionalLiquidationValue / tokenPrice) / fixedPointAccuracy;

            // get token collateral balance in vault, set to 0n if not found in vault (i.e. first deposit)
            var vaultTokenCollateralBalance : nat := case _vault.collateralBalanceLedger[tokenName] of [
                  Some(_balance) -> _balance
                | None -> 0n
            ];

            // calculate new collateral balance
            if tokenQuantityToBeLiquidated > vaultTokenCollateralBalance then failwith("Error. Token quantity to be liquidated cannot be more than balance of token collateral in vault.") else skip;
            const newTokenCollateralBalance : nat = abs(vaultTokenCollateralBalance - tokenQuantityToBeLiquidated);

            // send collateral to initiator of liquidation: pattern match withdraw operation based on token type
            const initiatorTakeCollateralOperation : operation = case collateralTokenRecord.tokenType of [
                Tez(_tez) -> block {
                    
                    const withdrawTezOperationParams : vaultWithdrawType = record [
                        from_ = _vault.address;
                        to_   = recipient; 
                        amt   = tokenQuantityToBeLiquidated;
                        token = Tez(_tez);
                    ];
                    const withdrawTezOperation : operation = Tezos.transaction(
                        withdrawTezOperationParams,
                        0mutez,
                        getVaultWithdrawEntrypoint(_vault.address)
                    );

                } with withdrawTezOperation
                | Fa12(_token) -> block {

                    const withdrawFa12OperationParams : vaultWithdrawType = record [
                        from_ = _vault.address;
                        to_   = recipient; 
                        amt   = tokenQuantityToBeLiquidated;
                        token = Fa12(_token);
                    ];
                    const withdrawFa12Operation : operation = Tezos.transaction(
                        withdrawFa12OperationParams,
                        0mutez,
                        getVaultWithdrawEntrypoint(_vault.address)
                    );

                } with withdrawFa12Operation
                | Fa2(_token) -> block {

                    const withdrawFa2OperationParams : vaultWithdrawType = record [
                        from_ = _vault.address;
                        to_   = recipient; 
                        amt   = tokenQuantityToBeLiquidated;
                        token = Fa2(_token);
                    ];
                    const withdrawFa2Operation : operation = Tezos.transaction(
                        withdrawFa2OperationParams,
                        0mutez,
                        getVaultWithdrawEntrypoint(_vault.address)
                    );

                } with withdrawFa2Operation
            ];

            operations := initiatorTakeCollateralOperation # operations;

            // save and update new balance for collateral token
            _vault.collateralBalanceLedger[tokenName]  := newTokenCollateralBalance;

        };

    };

    // operation to burn USDM
    const burnUsdmOperationParams : mintOrBurnParamsType = record [
        quantity = -usdmQuantity;
        target   = initiator;
    ];
    const burnUsdmOperation : operation = Tezos.transaction(
        burnUsdmOperationParams,
        0mutez,
        getUsdmMintOrBurnEntrypoint(s.usdmTokenAddress)
    );
    operations := burnUsdmOperation # operations;

    // save and update new usdmOutstanding and balance for collateral token
    _vault.usdmOutstanding                    := remainingUsdm;
    s.vaults[vaultHandle]                     := _vault;

} with (operations, s)



(* mintOrBurn entrypoint *)
function mintOrBurn(const mintOrBurnParams : mintOrBurnActionType; var s : controllerStorage) : return is 
block {
    
    // init variables for convenience
    const id                : nat                     = mintOrBurnParams.id; 
    var quantity            : int                    := mintOrBurnParams.quantity;
    const initiator         : initiatorAddressType    = Tezos.get_sender();
    var operations          : list(operation)        := nil;

    // make vault handle
    const vaultHandle : vaultHandleType = record [
        id     = id;
        owner  = initiator;
    ];

    // get vault if exists
    var vault : vaultType := getVault(vaultHandle, s);

    // check if quantity to burn exceeds vault's usdmOutstanding
    if vault.usdmOutstanding + quantity < 0 then failwith("Error. Cannot burn more than outstanding amount of USDM.") else skip;
    const newUsdmOutstanding : usdmAmountType = abs(vault.usdmOutstanding + quantity); 
    vault.usdmOutstanding := newUsdmOutstanding;    

    // check if vault is undercollaterized; if it is not, then create and send mintOrBurn operation to USDM Token Contract
    if isUnderCollaterized(vault, s) 
    then failwith("Error. Excessive USDM minting and vault will be undercollaterized.")
    else skip;

    // charge a minimum loan fee if user is minting USDM
    if quantity > 0 then block {

        const minimumLoanFee   : nat = s.config.minimumLoanFee;
        const decimals         : nat = s.config.decimals;

        const minimumFeeToPay  : int = quantity * minimumLoanFee / decimals;

        // Get treasury address
        const treasuryAddress : address = case s.generalContracts["treasury"] of [
              Some(_address) -> _address
            | None           -> failwith("Error. Treasury Address not found.")
        ];

        const mintMinimumFeeToTreasuryParams : mintOrBurnParamsType = record [
            quantity = minimumFeeToPay;
            target   = treasuryAddress;
        ];

        const mintMinimumFeeToTreasuryOperation : operation = Tezos.transaction(
            mintMinimumFeeToTreasuryParams,
            0mutez,
            getUsdmMintOrBurnEntrypoint(s.usdmTokenAddress)
        );

        operations := mintMinimumFeeToTreasuryOperation # operations;

        // reduce quantity to mint by minimum fee
        if minimumFeeToPay > quantity then failwith("Error. Minimum Fee to pay cannot be greater than quantity to mint.") else skip;
        quantity := quantity - minimumFeeToPay;

        // temp - calculate outstanding service fee amount
        if vault.usdmOutstanding > 0n then block {
            
            const lastMintBlockLevel   : nat   = vault.lastMintBlockLevel;
            const today                : nat   = Tezos.get_level();
            const dailyServiceLoanFee  : nat   = s.config.dailyServiceLoanFee;                   // daily service loan fee
            const blocksPerDay         : nat   = s.config.blocksPerMinute * 60n * 24n;           // 2880 blocks per day -> if 2 blocks per minute 
            
            const daysPassed           : nat   = abs(today - lastMintBlockLevel) / blocksPerDay; // only include whole days since remainder is not factored in division here
            const totalServiceLoanFee  : nat   = daysPassed * dailyServiceLoanFee; 

            // mint service loan fee amount to treasury
            const mintServiceLoanFeeToTreasuryParams : mintOrBurnParamsType = record [
                quantity = totalServiceLoanFee;
                target   = treasuryAddress;
            ];
            const mintServiceLoanFeeToTreasuryOperation : operation = Tezos.transaction(
                mintMinimumFeeToTreasuryParams,
                0mutez,
                getUsdmMintOrBurnEntrypoint(s.usdmTokenAddress)
            );

            operations := mintServiceLoanFeeToTreasuryOperation # operations;

            // update quantity to be minted
            if totalServiceLoanFee > quantity then failwith("Error. Total service loan fee cannot be greater than USDM quantity minted.") else skip;
            quantity := quantity - totalServiceLoanFee

            // update vault last mint block level
            vault.lastMintBlockLevel = Tezos.get_level();

        } else skip;

    } else skip;

    // create and send mintOrBurn operation to USDM Token Contract
    // const usdmMintOrBurnParams : mintOrBurnParamsType = (quantity, initiator);
    const usdmMintOrBurnParams : mintOrBurnParamsType = record [
        quantity = quantity;
        target   = initiator;
    ];
    const mintOrBurnOperation : operation = Tezos.transaction(
        usdmMintOrBurnParams,
        0mutez,
        getUsdmMintOrBurnEntrypoint(s.usdmTokenAddress)
    );
    operations := mintOrBurnOperation # operations;

    // update vault
    s.vaults[vaultHandle] := vault;

} with (operations, s)



(* vaultDepositStakedMvk entrypoint *)
function vaultDepositStakedMvk(const vaultDepositStakedMvkParams : vaultDepositStakedMvkType; var s : controllerStorage) : return is 
block {

    // init variables for convenience
    const vaultId         : vaultIdType       = vaultDepositStakedMvkParams.vaultId;
    const depositAmount   : nat               = vaultDepositStakedMvkParams.depositAmount;
    const vaultOwner      : vaultOwnerType    = Tezos.get_sender();
    const tokenName       : string            = "sMVK";
    var operations        : list(operation)  := nil;

    // check if token (sMVK) exists in collateral token ledger
    const _collateralTokenRecord : collateralTokenRecordType = case s.collateralTokenLedger[tokenName] of [
          Some(_record) -> _record
        | None -> failwith("Error. Collateral Token Record not found in collateralTokenLedger.")
    ];

    // make vault handle
    const vaultHandle : vaultHandleType = record [
        id     = vaultId;
        owner  = vaultOwner;
    ];

    // get vault
    var vault : vaultType := getVault(vaultHandle, s);

    // Find doorman Token Controller address
    const doormanAddress : address = case s.generalContracts["doorman"] of [
          Some(_address) -> _address
        | None           -> failwith("Error. Doorman contract not found.")
    ];

    // create operation to doorman to update balance of staked MVK from user to vault
    const vaultDepositStakedMvkOperation : operation = Tezos.transaction(
        vaultDepositStakedMvkParams,
        0tez,
        getVaultDepositStakedMvkEntrypoint(doormanAddress)
    );
    operations := vaultDepositStakedMvkOperation # operations;
    
    // get token collateral balance in vault, set to 0n if not found in vault (i.e. first deposit)
    var vaultTokenCollateralBalance : nat := case vault.collateralBalanceLedger[tokenName] of [
          Some(_balance) -> _balance
        | None           -> 0n
    ];

    // calculate new collateral balance
    const newCollateralBalance : nat = vaultTokenCollateralBalance + depositAmount;

    // save and update new balance for collateral token
    vault.collateralBalanceLedger[tokenName]  := newCollateralBalance;
    s.vaults[vaultHandle]                     := vault;

} with (operations, s)



(* vaultWithdrawStakedMvk entrypoint *)
function vaultWithdrawStakedMvk(const vaultWithdrawStakedMvkParams : vaultWithdrawStakedMvkType; var s : controllerStorage) : return is 
block {

    // init variables for convenience
    const vaultId         : vaultIdType       = vaultWithdrawStakedMvkParams.vaultId;
    const withdrawAmount  : nat               = vaultWithdrawStakedMvkParams.withdrawAmount;
    const vaultOwner      : vaultOwnerType    = Tezos.get_sender();
    const tokenName       : string            = "sMVK";
    var operations        : list(operation)  := nil;

    // check if token (sMVK) exists in collateral token ledger
    const _collateralTokenRecord : collateralTokenRecordType = case s.collateralTokenLedger[tokenName] of [
          Some(_record) -> _record
        | None -> failwith("Error. Collateral Token Record not found in collateralTokenLedger.")
    ];

    // make vault handle
    const vaultHandle : vaultHandleType = record [
        id     = vaultId;
        owner  = vaultOwner;
    ];

    // get vault
    var vault : vaultType := getVault(vaultHandle, s);

    // Find doorman Token Controller address
    const doormanAddress : address = case s.generalContracts["doorman"] of [
          Some(_address) -> _address
        | None           -> failwith("Error. Doorman contract not found.")
    ];

    // get token collateral balance in vault, set to 0n if not found in vault (i.e. first deposit)
    var vaultTokenCollateralBalance : nat := case vault.collateralBalanceLedger[tokenName] of [
          Some(_balance) -> _balance
        | None           -> 0n
    ];

    // calculate new collateral balance
    if withdrawAmount > vaultTokenCollateralBalance then failwith("Error. You do not have enough collateral balance.") else skip;
    const newCollateralBalance : nat = abs(vaultTokenCollateralBalance - withdrawAmount);

    // create operation to doorman to update balance of staked MVK from user to vault
    const vaultWithdrawStakedMvkOperation : operation = Tezos.transaction(
        vaultWithdrawStakedMvkParams,
        0tez,
        getVaultWithdrawStakedMvkEntrypoint(doormanAddress)
    );
    operations := vaultWithdrawStakedMvkOperation # operations;
    
    // save and update new balance for collateral token
    vault.collateralBalanceLedger[tokenName]  := newCollateralBalance;
    s.vaults[vaultHandle]                     := vault;

} with (operations, s)



(* vaultLiquidateStakedMvk entrypoint *)
function vaultLiquidateStakedMvk(const vaultLiquidateStakedMvkParams : vaultLiquidateStakedMvkType; var s : controllerStorage) : return is 
block {

    // only callable from self (i.e. from LiquidateVault entrypoint, if owner of vault being liquidated has staked mvk as collateral)
    checkSenderIsSelf(unit);

    // init variables for convenience
    const vaultId           : vaultIdType       = vaultLiquidateStakedMvkParams.vaultId;
    const vaultOwner        : vaultOwnerType    = vaultLiquidateStakedMvkParams.vaultOwner;
    const liquidatedAmount  : nat               = vaultLiquidateStakedMvkParams.liquidatedAmount;
    const _liquidator        : address          = vaultLiquidateStakedMvkParams.liquidator;
    
    const tokenName       : string            = "sMVK";
    var operations        : list(operation)  := nil;

    // check if token (sMVK) exists in collateral token ledger
    const _collateralTokenRecord : collateralTokenRecordType = case s.collateralTokenLedger[tokenName] of [
          Some(_record) -> _record
        | None -> failwith("Error. Collateral Token Record not found in collateralTokenLedger.")
    ];

    // make vault handle
    const vaultHandle : vaultHandleType = record [
        id     = vaultId;
        owner  = vaultOwner;
    ];

    // get vault
    var vault : vaultType := getVault(vaultHandle, s);

    // Find doorman Token Controller address
    const doormanAddress : address = case s.generalContracts["doorman"] of [
          Some(_address) -> _address
        | None           -> failwith("Error. Doorman contract not found.")
    ];

    // get token collateral balance in vault, set to 0n if not found in vault (i.e. first deposit)
    var vaultTokenCollateralBalance : nat := case vault.collateralBalanceLedger[tokenName] of [
          Some(_balance) -> _balance
        | None           -> failwith("Error. Vault collateral has zero balalnce.")
    ];

    // calculate new collateral balance
    if liquidatedAmount > vaultTokenCollateralBalance then failwith("Error. You do not have enough collateral balance.") else skip;
    const newCollateralBalance : nat = abs(vaultTokenCollateralBalance - liquidatedAmount);

    // create operation to doorman to update balance of staked MVK from user to vault
    const vaultLiquidateStakedMvkOperation : operation = Tezos.transaction(
        vaultLiquidateStakedMvkParams,
        0tez,
        getVaultLiquidateStakedMvkEntrypoint(doormanAddress)
    );
    operations := vaultLiquidateStakedMvkOperation # operations;
    
    // save and update new balance for collateral token in liquidated vault
    vault.collateralBalanceLedger[tokenName]  := newCollateralBalance;
    s.vaults[vaultHandle]                     := vault;

} with (operations, s)



(* onPriceAction entrypoint *)
function onPriceAction(const onPriceActionParams : onPriceActionType; var s : controllerStorage) : return is 
block {

    // init variables for convenience
    const cashAmount        : nat               = onPriceActionParams.cashAmount;
    const tokenAmount       : nat               = onPriceActionParams.tokenAmount;
    const tokenName         : string            = onPriceActionParams.tokenName;

    const cfmmAddress : address = case s.cfmmAddressLedger[tokenName] of [
          Some(_address) -> _address
        | None           -> failwith("Error. CFMM Address not found in CFMM Ledger.")
    ];

    // check if sender is from the cfmm address
    if Tezos.get_sender() =/= cfmmAddress then failwith("Error. Caller must be CFMM contract.")  else skip;

    var lastDriftUpdate : timestamp := case s.lastDriftUpdateLedger[tokenName] of [
          Some(_timestamp) -> _timestamp
        | None -> Tezos.get_now() - 300           // if no drift update is found for token, set to 5 minutes ago
    ];

    // check that last drift update is before current time
    if lastDriftUpdate > Tezos.get_now() then failwith("Error. Delta cannot be negative.") else skip;
    const delta   : nat   = abs(Tezos.get_now() - lastDriftUpdate); 

    var target : nat  := case s.targetLedger[tokenName] of [
          Some(_nat) -> _nat
        | None -> failwith("Error. Target not found for this pair.")
    ];

    var drift : int  := case s.driftLedger[tokenName] of [
          Some(_int) -> _int
        | None -> failwith("Error. Drift not found for this pair.")
    ];

    var d_target  : nat  := (target * abs(drift) * delta) / fixedPointAccuracy;

    target := if drift < 0 then abs(target - d_target) else target + d_target;

    const price            : nat   = (cashAmount * fixedPointAccuracy) / tokenAmount;
    const targetLessPrice  : int   = target - price;

    const x                : nat    = (abs(targetLessPrice * targetLessPrice) / fixedPointAccuracy);
    const priceSquared     : nat    = price * price; 
    const d_drift          : nat    = if x > priceSquared then delta else delta / priceSquared;

    var drift              : int    := if targetLessPrice > 0 then drift + d_drift else drift - d_drift;

    s.targetLedger[tokenName]            := target;
    s.driftLedger[tokenName]             := drift;
    s.lastDriftUpdateLedger[tokenName]   := Tezos.get_now();
    s.priceLedger[tokenName]             := price;           

    // math may not be completely correct with the divisions - double check with ctez/checker formula

} with (noOperations, s)



(* getTarget entrypoint *)
function getTarget(const getTargetParams : getTargetActionType; var s : controllerStorage) : return is 
block {

    // init variables
    const tokenName          : string         = getTargetParams.tokenName;
    const callbackContract   : contract(nat)  = getTargetParams.callbackContract;

    const target : nat = case s.targetLedger[tokenName] of [
        Some(_target) -> _target
        | None -> failwith("Error. No target found in target ledger.")
    ];

    const callbackOperation : operation = Tezos.transaction(
        target,
        0mutez,
        callbackContract
    );

} with (list[callbackOperation], s)




function main (const action : controllerAction; const s : controllerStorage) : return is 
    case action of [

        | Default(_params) -> ((nil : list(operation)), s)
        
        | UpdateGeneralContracts(parameters)            -> updateGeneralContracts(parameters, s)
        | UpdateWhitelistTokenContracts(parameters)     -> updateWhitelistTokenContracts(parameters, s)
        | UpdateCollateralTokenLedger(parameters)       -> updateCollateralTokenLedger(parameters, s)
        | UpdateCfmmAddressLedger(parameters)           -> updateCfmmAddressLedger(parameters, s)
        | SetUsdmAddress(parameters)                    -> setUsdmAddress(parameters, s)

        | CreateVault(parameters)                       -> createVault(parameters, s)
        | CloseVault(parameters)                        -> closeVault(parameters, s)
        | LiquidateVault(parameters)                    -> liquidateVault(parameters, s)
        | RegisterDeposit(parameters)                   -> registerDeposit(parameters, s)
        | WithdrawFromVault(parameters)                 -> withdrawFromVault(parameters, s)
        | MintOrBurn(parameters)                        -> mintOrBurn(parameters, s)

          // Staked MVK Entrypoints   
        | VaultDepositStakedMvk(parameters)             -> vaultDepositStakedMvk(parameters, s)
        | VaultWithdrawStakedMvk(parameters)            -> vaultWithdrawStakedMvk(parameters, s)
        | VaultLiquidateStakedMvk(parameters)           -> vaultLiquidateStakedMvk(parameters, s)

        | OnPriceAction(parameters)                     -> onPriceAction(parameters, s)
        | GetTarget(parameters)                         -> getTarget(parameters, s)

    ]