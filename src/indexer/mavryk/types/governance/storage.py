# generated by datamodel-codegen:
#   filename:  storage.json

from __future__ import annotations

from typing import Any, Dict, List, Optional, Union

from pydantic import BaseModel, Extra, Field


class Config(BaseModel):
    class Config:
        extra = Extra.forbid

    successReward: str
    cycleVotersReward: str
    minProposalRoundVotePercentage: str
    minProposalRoundVotesRequired: str
    minQuorumPercentage: str
    minYayVotePercentage: str
    proposalSubmissionFeeMutez: str
    maxProposalsPerSatellite: str
    blocksPerProposalRound: str
    blocksPerVotingRound: str
    blocksPerTimelockRound: str
    proposalDataTitleMaxLength: str
    proposalTitleMaxLength: str
    proposalDescriptionMaxLength: str
    proposalInvoiceMaxLength: str
    proposalSourceCodeMaxLength: str


class ProposalDatum(BaseModel):
    class Config:
        extra = Extra.forbid

    title: str
    encodedCode: str
    codeDescription: str


class TokenItem(BaseModel):
    class Config:
        extra = Extra.forbid

    fa12: str


class Fa2(BaseModel):
    class Config:
        extra = Extra.forbid

    tokenContractAddress: str
    tokenId: str


class TokenItem1(BaseModel):
    class Config:
        extra = Extra.forbid

    fa2: Fa2


class TokenItem2(BaseModel):
    class Config:
        extra = Extra.forbid

    tez: Dict[str, Any]


class Transaction(BaseModel):
    class Config:
        extra = Extra.forbid

    to_: str
    amount: str
    token: Union[TokenItem, TokenItem1, TokenItem2]


class PaymentDatum(BaseModel):
    class Config:
        extra = Extra.forbid

    title: str
    transaction: Transaction


class ProposalLedger(BaseModel):
    class Config:
        extra = Extra.forbid

    proposerAddress: str
    proposalData: Dict[str, Optional[ProposalDatum]]
    proposalDataExecutionCounter: str
    paymentData: Dict[str, Optional[PaymentDatum]]
    status: str
    title: str
    description: str
    invoice: str
    sourceCode: str
    successReward: str
    totalVotersReward: str
    executed: bool
    paymentProcessed: bool
    locked: bool
    rewardClaimReady: bool
    executionReady: bool
    proposalVoteCount: str
    proposalVoteStakedMvkTotal: str
    minProposalRoundVotePercentage: str
    minProposalRoundVotesRequired: str
    yayVoteCount: str
    yayVoteStakedMvkTotal: str
    nayVoteCount: str
    nayVoteStakedMvkTotal: str
    passVoteCount: str
    passVoteStakedMvkTotal: str
    minQuorumPercentage: str
    minQuorumStakedMvkTotal: str
    minYayVotePercentage: str
    quorumCount: str
    quorumStakedMvkTotal: str
    startDateTime: str
    executedDateTime: str
    cycle: str
    currentCycleStartLevel: str
    currentCycleEndLevel: str


class Key(BaseModel):
    class Config:
        extra = Extra.forbid

    nat: str
    address: str


class ValueItem(BaseModel):
    class Config:
        extra = Extra.forbid

    nay: Dict[str, Any]


class ValueItem1(BaseModel):
    class Config:
        extra = Extra.forbid

    pass_: Dict[str, Any] = Field(..., alias='pass')


class ValueItem2(BaseModel):
    class Config:
        extra = Extra.forbid

    yay: Dict[str, Any]


class ProposalVoter(BaseModel):
    class Config:
        extra = Extra.forbid

    key: Key
    value: Union[ValueItem, ValueItem1, ValueItem2]


class ProposalReward(BaseModel):
    class Config:
        extra = Extra.forbid

    key: Key
    value: Dict[str, Any]


class Value(BaseModel):
    class Config:
        extra = Extra.forbid

    totalStakedMvkBalance: str
    totalDelegatedAmount: str
    totalVotingPower: str
    accumulatedRewardsPerShare: str
    ready: bool


class SnapshotLedgerItem(BaseModel):
    class Config:
        extra = Extra.forbid

    key: Key
    value: Value


class RoundItem(BaseModel):
    class Config:
        extra = Extra.forbid

    proposal: Dict[str, Any]


class RoundItem1(BaseModel):
    class Config:
        extra = Extra.forbid

    timelock: Dict[str, Any]


class RoundItem2(BaseModel):
    class Config:
        extra = Extra.forbid

    voting: Dict[str, Any]


class CurrentCycleInfo(BaseModel):
    class Config:
        extra = Extra.forbid

    round: Union[RoundItem, RoundItem1, RoundItem2]
    blocksPerProposalRound: str
    blocksPerVotingRound: str
    blocksPerTimelockRound: str
    roundStartLevel: str
    roundEndLevel: str
    cycleEndLevel: str
    cycleTotalVotersReward: str
    minQuorumStakedMvkTotal: str


class CycleProposer(BaseModel):
    class Config:
        extra = Extra.forbid

    key: Key
    value: List[str]


class ValueItem3(BaseModel):
    class Config:
        extra = Extra.forbid

    proposal: str


class ValueItem4(BaseModel):
    class Config:
        extra = Extra.forbid

    nay: Dict[str, Any]


class ValueItem5(BaseModel):
    class Config:
        extra = Extra.forbid

    pass_: Dict[str, Any] = Field(..., alias='pass')


class ValueItem6(BaseModel):
    class Config:
        extra = Extra.forbid

    yay: Dict[str, Any]


class RoundVote(BaseModel):
    class Config:
        extra = Extra.forbid

    key: Key
    value: Union[ValueItem3, ValueItem4, ValueItem5, ValueItem6]


class GovernanceStorage(BaseModel):
    class Config:
        extra = Extra.forbid

    admin: str
    metadata: Dict[str, str]
    config: Config
    mvkTokenAddress: str
    governanceProxyAddress: str
    whitelistContracts: Dict[str, Dict[str, Any]]
    generalContracts: Dict[str, str]
    whitelistDevelopers: List[str]
    proposalLedger: Dict[str, ProposalLedger]
    proposalVoters: List[ProposalVoter]
    proposalRewards: List[ProposalReward]
    snapshotLedger: List[SnapshotLedgerItem]
    stakedMvkSnapshotLedger: Dict[str, str]
    currentCycleInfo: CurrentCycleInfo
    cycleProposals: Dict[str, str]
    cycleProposers: List[CycleProposer]
    roundVotes: List[RoundVote]
    nextProposalId: str
    cycleId: str
    cycleHighestVotedProposalId: str
    timelockProposalId: str
    lambdaLedger: Dict[str, str]
