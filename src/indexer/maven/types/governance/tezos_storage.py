# generated by datamodel-codegen:
#   filename:  tezos_storage.json

from __future__ import annotations

from typing import Any, Dict, List

from pydantic import BaseModel, Extra, Field


class Config(BaseModel):
    class Config:
        extra = Extra.forbid

    successReward: str
    cycleVotersReward: str
    minProposalRoundVotePercentage: str
    minQuorumPercentage: str
    minYayVotePercentage: str
    proposalSubmissionFeeMumav: str
    maxProposalsPerSatellite: str
    blocksPerProposalRound: str
    blocksPerVotingRound: str
    blocksPerTimelockRound: str
    proposalDataTitleMaxLength: str
    proposalTitleMaxLength: str
    proposalDescriptionMaxLength: str
    proposalInvoiceMaxLength: str
    proposalSourceCodeMaxLength: str


class ProposalData(BaseModel):
    class Config:
        extra = Extra.forbid

    title: str
    encodedCode: str
    codeDescription: str


class Token(BaseModel):
    class Config:
        extra = Extra.forbid

    fa12: str


class Fa2(BaseModel):
    class Config:
        extra = Extra.forbid

    tokenContractAddress: str
    tokenId: str


class Token1(BaseModel):
    class Config:
        extra = Extra.forbid

    fa2: Fa2


class Token2(BaseModel):
    class Config:
        extra = Extra.forbid

    mav: Dict[str, Any]


class Transaction(BaseModel):
    class Config:
        extra = Extra.forbid

    to_: str
    amount: str
    token: Token | Token1 | Token2


class PaymentData(BaseModel):
    class Config:
        extra = Extra.forbid

    title: str
    transaction: Transaction


class ProposalLedger(BaseModel):
    class Config:
        extra = Extra.forbid

    proposerAddress: str
    proposalData: Dict[str, ProposalData | None]
    proposalDataExecutionCounter: str
    paymentData: Dict[str, PaymentData | None]
    status: str
    title: str
    description: str
    invoice: str
    sourceCode: str
    successReward: str
    totalVotersReward: str
    executed: bool
    paymentProcessed: bool
    locked: bool
    rewardClaimReady: bool
    executionReady: bool
    proposalVoteCount: str
    proposalVoteStakedMvnTotal: str
    minProposalRoundVotePercentage: str
    minProposalRoundVotesRequired: str
    yayVoteCount: str
    yayVoteStakedMvnTotal: str
    nayVoteCount: str
    nayVoteStakedMvnTotal: str
    passVoteCount: str
    passVoteStakedMvnTotal: str
    minQuorumPercentage: str
    minQuorumStakedMvnTotal: str
    minYayVotePercentage: str
    quorumCount: str
    quorumStakedMvnTotal: str
    startDateTime: str
    executedDateTime: str | None
    cycle: str
    currentCycleStartLevel: str
    currentCycleEndLevel: str


class Key(BaseModel):
    class Config:
        extra = Extra.forbid

    nat: str
    address: str


class Value(BaseModel):
    class Config:
        extra = Extra.forbid

    nay: Dict[str, Any]


class Value1(BaseModel):
    class Config:
        extra = Extra.forbid

    pass_: Dict[str, Any] = Field(..., alias='pass')


class Value2(BaseModel):
    class Config:
        extra = Extra.forbid

    yay: Dict[str, Any]


class ProposalVoter(BaseModel):
    class Config:
        extra = Extra.forbid

    key: Key
    value: Value | Value1 | Value2


class ProposalReward(BaseModel):
    class Config:
        extra = Extra.forbid

    key: Key
    value: Dict[str, Any]


class Value3(BaseModel):
    class Config:
        extra = Extra.forbid

    totalStakedMvnBalance: str
    totalDelegatedAmount: str
    totalVotingPower: str
    accumulatedRewardsPerShare: str
    ready: bool
    nextSnapshotCycleId: str | None


class SnapshotLedgerItem(BaseModel):
    class Config:
        extra = Extra.forbid

    key: Key
    value: Value3


class Round(BaseModel):
    class Config:
        extra = Extra.forbid

    proposal: Dict[str, Any]


class Round1(BaseModel):
    class Config:
        extra = Extra.forbid

    timelock: Dict[str, Any]


class Round2(BaseModel):
    class Config:
        extra = Extra.forbid

    voting: Dict[str, Any]


class CurrentCycleInfo(BaseModel):
    class Config:
        extra = Extra.forbid

    round: Round | Round1 | Round2
    blocksPerProposalRound: str
    blocksPerVotingRound: str
    blocksPerTimelockRound: str
    roundStartLevel: str
    roundEndLevel: str
    cycleEndLevel: str
    cycleTotalVotersReward: str
    minQuorumStakedMvnTotal: str


class CycleProposer(BaseModel):
    class Config:
        extra = Extra.forbid

    key: Key
    value: List[str]


class Value4(BaseModel):
    class Config:
        extra = Extra.forbid

    proposal: str


class Value5(BaseModel):
    class Config:
        extra = Extra.forbid

    nay: Dict[str, Any]


class Value6(BaseModel):
    class Config:
        extra = Extra.forbid

    pass_: Dict[str, Any] = Field(..., alias='pass')


class Value7(BaseModel):
    class Config:
        extra = Extra.forbid

    yay: Dict[str, Any]


class RoundVote(BaseModel):
    class Config:
        extra = Extra.forbid

    key: Key
    value: Value4 | Value5 | Value6 | Value7


class GovernanceStorage(BaseModel):
    class Config:
        extra = Extra.forbid

    admin: str
    metadata: Dict[str, str]
    config: Config
    mvnTokenAddress: str
    governanceProxyAddress: str
    whitelistContracts: Dict[str, Dict[str, Any]]
    generalContracts: Dict[str, str]
    whitelistDevelopers: List[str]
    proposalLedger: Dict[str, ProposalLedger]
    proposalVoters: List[ProposalVoter]
    proposalRewards: List[ProposalReward]
    snapshotLedger: List[SnapshotLedgerItem]
    satelliteLastSnapshotLedger: Dict[str, str]
    stakedMvnSnapshotLedger: Dict[str, str]
    currentCycleInfo: CurrentCycleInfo
    cycleProposals: Dict[str, str]
    cycleProposers: List[CycleProposer]
    roundVotes: List[RoundVote]
    nextProposalId: str
    cycleId: str
    cycleHighestVotedProposalId: str
    timelockProposalId: str
    lambdaLedger: Dict[str, str]
